Copyright 2014 (c) Sizing Servers Lab
University College of West-Flanders, Department GKG * 
Author(s):
    Dieter Vandroemme

Preface
------------------------------
All boilerplate code for Java based agents resides in be.sizingservers.vapus.agent in the vApus-agent project.
It implements the communication protocol as stated in the Sizing Servers wiki: http://wiki.sizingservers.be/index.php/VApus-vApus-agent_communication_protocol

You should also add vApus-agent-util and gson-2.2.4 to libraries.

Important: These classes are coded against Java 6 for backwards compatibility reasons.

1) Writing an agent
------------------------------

A good example is the vApus-hmt monitor.

1.1) Classes
------------------------------
Basically you need three classes (+ your own helper classes):
    A monitor class: Extend from be.sizingservers.vapus.agent.Monitor.
                     Most work must be done here because getting counters is obviously very monitor-type specific.
                     Since entities (for instance, a computer), headers and counters need to be json formatted: serialize an instance of be.sizingservers.util.Entities. 
                     Make sure you do not have shared data between monitor instances. (One monitor per user)
					 
					 Related to the monitor class: 1.3 Proxies.
    
    A server class:  Extend from be.sizingservers.vapus.agent.Server and implement getNewMonitor(...).
                     This returns a new monitor that is used in the super class.
                     In the super class resides a simple TCP (IPv4/IPv6) server socket.
                     It provides a monitor instance per connection.
    
    An agent class:  The main entry point of the application. 
                     Combines a server with an agent. 
                     Extend from be.sizingservers.vapus.agent.Agent and call the super.main(...) in the main fx.


1.2) .properties files
------------------------------
You need 2 .properties files.

Add a vApus-agent.properties to the default package. Use following as a template:

    # Copyright 2014 (c) Sizing Servers Lab
    # University College of West-Flanders, Department GKG
    #
    # Author(s):
    # 	<insert your name here>
    
    # None of following properties can be ommited.
    
    # The name of the monitor.
    name=vApus-dstat
    
    #The version of this monitor.
    version=0.1
    
    copyright=Copyright 2014 (c) Sizing Servers Lab\nUniversity College of West-Flanders, Department GKG
    
    #The port the server will listen at.
    defaultPort=5556
    
    #The interval that counters are sent to the client in milliseconds.
    sendCountersInterval=1000

    # Can be . or , depending on for example the locale. This is purely for parsing decimal values client-side.
    decimalSeparator=.

Add a logging.properties to the default package. Use following as a template:

    # Copyright 2014 (c) Sizing Servers Lab
    # University College of West-Flanders, Department GKG
    #
    # Author(s):
    # 	Dieter Vandroemme
    
    # Execute locate logging.properties for example (default properties in jdk).
    
    handlers= java.util.logging.FileHandler, java.util.logging.ConsoleHandler
    
    # Global logging level.
    .level= SEVERE
    
    # Outputs in the apps dir. u% == unique number.
    java.util.logging.FileHandler.pattern = vApus-dstat%u.log
    java.util.logging.FileHandler.limit = 50000
    java.util.logging.FileHandler.count = 1
    
    # Other formatters, like XMLFormatter, are possible. This outputs to flat file.
    java.util.logging.FileHandler.formatter = java.util.logging.SimpleFormatter
    
    java.util.logging.ConsoleHandler.formatter = java.util.logging.SimpleFormatter
	

1.3) Proxies
------------------------------
If you want to monitor OS specific stuff, it is most likely that you cannot do that from within a Java VM.
Therefore you can write a proxy: Execute functions in C libraries using JNA (Java Native Access).

Example for getting CPUID registers:

    /*
     * Copyright 2014 (c) Sizing Servers Lab
     * University College of West-Flanders, Department GKG * 
     * Author(s):
     * 	Dieter Vandroemme
     */
    package be.sizingservers.vapus.hmt.agent.cpu;
 
    import com.sun.jna.Library;
    import com.sun.jna.Native;
 
    /**
     * JNA proxy to a binary that works on Windows and Linux.
     */
    public interface CPUIDProxy extends Library {
        CPUIDProxy INSTANCE = (CPUIDProxy) Native.loadLibrary(System.getProperty("os.name").startsWith("Windows") ? "/cpuid.dll" : "/cpuid.so", CPUIDProxy.class);
      
        public long load(long i);
        public long EAX();
        public long EBX();
        public long ECX();
        public long EDX();
    }
 
If you want to make a C library for Windows, you can make a .Net Visual Studio Solution.
You add the nuget package for RGiesecke DllExport to your project. Check the DllExport readme for the caveats.

In that case you can copy referenced binaries to the agent build folder by including a post-jar target in the Netbeans build.xml, right below the import tag.
 
Example:
 
    <target name="-post-jar"> 
        <copy file="src/Newtonsoft.Json.dll" flatten="true" todir="${dist.dir}"/> 
    </target>